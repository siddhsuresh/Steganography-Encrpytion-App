<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>eclipse.src.discrete_cosine_transform_tool API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eclipse.src.discrete_cosine_transform_tool</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from itertools import product
import random
from warnings import warn
from os.path import abspath
from cv2 import resize, imwrite, dct, idct
import numpy as np
from bitstring import BitArray

from eclipse.common import settings, utils


class DCT:
    def __init__(self, cover_image_path, cipher_msg):
        self.__cover_image_path_ = abspath(cover_image_path)
        self.__cover_image_ = utils.get_image(cover_image_path)
        self.verify_and_apply_padding()
        self.__height_, self.__width_ = self.__cover_image_.shape[:2]
        self.__cipher_text_ = cipher_msg
        self.__bin_message_ = BitArray(bytes=cipher_msg).bin
        self.__message_length_ = len(self.__bin_message_)
        self.verify_ciphertext_size()

        self.__block_list_ = None

    # VERIFICATION METHODS ============================================================

    def verify_ciphertext_size(self):
        &#34;&#34;&#34;
        Verifies that the length of the message to hide
        is shorter than the maximum available space in the image.
        Warning is raised if the message length is &gt; (10% of the available capacity).
        &#34;&#34;&#34;
        area = self.__height_ * self.__width_
        if area &lt; 64:  # 64 -&gt; since each quantized block is a matrix of 8x8
            raise ValueError(
                &#34;The chosen cover image is too small (area &lt; 64 px)&#34;)
        tot_blocks = self.__height_ * self.__width_ // 64
        if self.__message_length_ &gt; tot_blocks:
            raise OverflowError(&#34;Cannot embed. Message is too long!&#34;)
        if self.__message_length_ &gt; tot_blocks / 10:
            purcentage_of_occupied_storage = round(
                self.__message_length_ / tot_blocks * 100)
            warning = f&#34;Message occupies ≈ &#34; \
                      f&#34;{purcentage_of_occupied_storage}% of the pic. &#34; \
                      &#34;A smaller text is preferred (&lt; 10%)&#34;
            warn(warning)

    def verify_and_apply_padding(self):
        &#34;&#34;&#34;
        Checks and eventually resizes image applying a padding
        if any side length is not a multiple of 8.
        The original image is eventually replaced by the padded
        (with sides multiple of 8) image.
        &#34;&#34;&#34;
        original_height, original_width = self.__cover_image_.shape[:2]
        if original_height % 8 != 0 or original_width % 8 != 0:
            self.__cover_image_ = resize(self.__cover_image_, (
                original_width + (8 - original_width % 8),
                original_height + (8 - original_height % 8)))
            imwrite(self.__cover_image_path_, self.__cover_image_)

    # BREAK/RECOMPOSE METHODS =========================================================

    @staticmethod
    def break_image_into_blocks(img: np.ndarray) -&gt; list:
        &#34;&#34;&#34;
        Breaks the coverimage into a sequence of 8x8 blocks,
        from top left to bottom right.
        :param img: Coverimage to break into n 8x8 blocks.
        :return: List of blocks of pixels [LIST OF NUMPY NDARRAY]
        &#34;&#34;&#34;
        if not isinstance(img, np.ndarray):
            raise TypeError(&#34;Cannot break a non np.array image&#34;)
        height, width = len(img), len(img[0])
        return [img[j: j + 8, i: i + 8] for (j, i) in
                product(range(0, height, 8), range(0, width, 8))
                ]

    def recompose_image(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Inverse of method &#39;breakImageIntoBlocks&#39;:
        Recompose the image from the sorted list of blocks of pixels &#39;__block_list_&#39;.
        :return: Re-composed image [NUMPY NDARRAY]
        &#34;&#34;&#34;
        if len(self.__block_list_) == 0:
            raise ValueError
        full_image = np.zeros(shape=(self.__height_, self.__width_),
                              dtype=np.uint8)  # Builds empty image
        for i in range(len(self.__block_list_)):  # Filling image
            curr_col_index = 8 * (i % (self.__width_ // 8))
            curr_line_index = 8 * (i // (self.__width_ // 8))
            full_image[
            curr_line_index:curr_line_index + 8,
            curr_col_index:curr_col_index + 8
            ] = self.__block_list_[i]
        return full_image

    # QUANTIZATION METHODS ============================================================

    @staticmethod
    def quantize_block(block: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Centers values of a block, runs it through DCT func. and quantizes it.
        :param block: 8x8 block of pixels [NUMPY NDARRAY]
        :return:Quantized 8x8 block of pixels [NUMPY NDARRAY]
        &#34;&#34;&#34;
        img_block = np.subtract(block, 128)
        dct_block = dct(img_block.astype(np.float64))
        dct_block[0][0] /= settings.QUANTIZATION_TABLE[0][0]
        dct_block[0][0] = np.round(dct_block[0][0])
        return dct_block

    @staticmethod
    def get_original_block_from_quantized(quantized_block: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Inverse of &#34;getQuantizedBlock&#34;.
        :param quantized_block: Quantized 8x8 block of pixels [NUMPY NDARRAY]
        :return: Original 8x8 block of pixels [NUMPY NDARRAY]
        &#34;&#34;&#34;
        dct_block = quantized_block
        dct_block[0][0] *= settings.QUANTIZATION_TABLE[0][0]
        unquantized_block = idct(dct_block)
        return np.add(unquantized_block, 128)

    # LENGTH EMBED/EXTRACT METHODS ====================================================

    def length_to_binary(self) -&gt; list:
        &#34;&#34;&#34;
        Gives binary form of the length and adds a separator to that representation.
        :return: Binary representation of the length + separator to embed [LIST OF STR]
        &#34;&#34;&#34;
        if self.__message_length_ % 8 != 0:
            raise ValueError(&#34;Message length is not multiple of 8&#34;)
        msg_length = int(
            self.__message_length_ / 8
        )  # Decimal representation of the length
        n_required_bits = msg_length.bit_length()
        tmp = f&#34;0{n_required_bits}b&#34;
        binary_length = format(msg_length, tmp)
        return list(binary_length) + utils.string_to_binary(
            settings.LENGTH_MSG_SEPARATOR)

    def embed_msg_length(self):
        &#34;&#34;&#34;
        Inserts the length of the message and end symbol (in binary form)
        at the beginning of the picture.
        At the end, &#39;__block_list_&#39; will be the image with embedded length,
        as list of blocks of pixels (from top left to bottom right) [LIST OF
                                                                    NUMPY NDARRAY]
        &#34;&#34;&#34;
        mess_len_to_binary = self.length_to_binary()
        for block_index, length_bit_to_embed in enumerate(mess_len_to_binary):
            quantized_block = self.quantize_block(
                self.__block_list_[block_index])
            if quantized_block[0][0] % 2 == 1 and int(length_bit_to_embed) == 0:
                quantized_block[0][0] -= 1
            elif quantized_block[0][0] % 2 == 0 and int(
                    length_bit_to_embed) == 1:
                quantized_block[0][0] += 1
            self.__block_list_[
                block_index] = self.get_original_block_from_quantized(
                quantized_block)

    @staticmethod
    def extract_msg_length(img: np.ndarray) -&gt; int:
        &#34;&#34;&#34;
        Extracts the length (in bits) of the message embedded in the stegoimage.
        :param img: Stegoimage from which to extract the message [NUMPY NDARRAY]
        :return: Length of the message to extract from the stegoimage [INT]
        &#34;&#34;&#34;
        block_index = 0
        separator_found = False
        decoded_length = &#34;&#34;
        while (not separator_found) and (
                block_index &lt; settings.MAX_BITS_TO_ENCODE_LENGTH):
            block = utils.extract_block_from_image(img, block_index)
            unquantized_block = DCT.quantize_block(block)
            decoded_length += str(int(unquantized_block[0][0] % 2))
            if len(decoded_length) &gt; 8:
                current_letter = str(chr(int(decoded_length[-8:], 2)))
                if current_letter == settings.LENGTH_MSG_SEPARATOR:
                    separator_found = True
            block_index += 1
        return int(&#39;&#39;.join(decoded_length[:-8]), 2) * 8

    # ENCODE/DECODE MESSAGE METHODS ===================================================

    @staticmethod
    def get_random_blocks_from_msg_length(seed: int,
                                          binary_msg_length: int,
                                          height: int,
                                          width: int) -&gt; list:
        &#34;&#34;&#34;
        Generates a random sequence of indices, (interpreted as the position
        of bits of the message to embed/extract in/from the cover/stegoimage.
        :param seed: Chosen seed [INT]
        :param binary_msg_length: length of the message to extract
                                  from the stegoimage [INT]
        :param height: Height of the cover/stegoimage [INT]
        :param width: Width of the cover/stegoimage [INT]
        :return: List of indexes [LIST OF INT]
        &#34;&#34;&#34;
        tot_blocks = height * width // 64
        random.seed(seed)
        chosen_blocks_indices = random.sample(
            range(settings.MAX_BITS_TO_ENCODE_LENGTH, tot_blocks),
            binary_msg_length)
        return chosen_blocks_indices

    def embed_msg(self, output_path: str, seed: int) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Embed message into cover image:
        1 - Embed the length.
        2 - Embed the message equally distributing bits according
            to a random sequence of indices
            and inserting them in the LSB of DCT quantized blocks.
        :param output_path: Path of stegoimage that will be generated
                            after message insertion [STR]
        :param seed: Chosen seed [INT]
        :return: Stegoimage [NUMPY NDARRAY]
        &#34;&#34;&#34;
        y, cr, cb = utils.get_YCrCb_from_original_img(self.__cover_image_)
        mess_len = len(self.__cipher_text_)
        positions_lst = self.get_random_blocks_from_msg_length(seed, mess_len * 8,
                                                               self.__height_,
                                                               self.__width_)
        self.__block_list_ = self.break_image_into_blocks(cb)
        self.embed_msg_length()
        for message_index, block_index in enumerate(positions_lst):
            block = self.__block_list_[block_index]
            dct_block = self.quantize_block(block)
            coeff = int(dct_block[0][0])

            message_bit = self.__bin_message_[message_index]
            if (coeff % 2) == 1 and int(message_bit) == 0:
                dct_block[0][0] -= 1
            elif (coeff % 2) == 0 and int(message_bit) == 1:
                dct_block[0][0] += 1

            self.__block_list_[block_index] = self.get_original_block_from_quantized(
                dct_block
            )
        modified_cb = self.recompose_image()
        final_img_standard_format = utils.get_original_img_from_YCrCb(y,
                                                                      cr,
                                                                      modified_cb)
        imwrite(output_path, final_img_standard_format)
        return final_img_standard_format

    @staticmethod
    def extract_msg(stego_img_path: str, seed: int) -&gt; bytes:
        &#34;&#34;&#34;
        Extract a message from a stegoimage:
        1 - Extract the length of the message.
        2 - Generate the random sequence of indices.
        3 - Extract the message.
        :param stego_img_path: Path of stegoimage
                               from which to extract the message [STR]
        :param seed: Chosen seed [INT]
        :return: Message hidden in the stegoimage [BYTE STR]
        &#34;&#34;&#34;
        original_stego_img = utils.get_image(stego_img_path)
        _, _, cb = utils.get_YCrCb_from_original_img(original_stego_img)
        height, width = original_stego_img.shape[:2]
        msg_length = DCT.extract_msg_length(cb)
        positions_lst = DCT.get_random_blocks_from_msg_length(
            seed, msg_length, height, width)
        decoded_msg = &#34;0b&#34;
        block_list = DCT.break_image_into_blocks(cb)
        for message_index, block_index in enumerate(positions_lst):
            block_index = positions_lst[message_index]
            block = block_list[block_index]
            dct_block = DCT.quantize_block(block)
            coeff = int(dct_block[0][0])
            decoded_msg += str(
                coeff % 2)  # Adding to the message the currently read bit
        return BitArray(decoded_msg).bytes


if __name__ == &#34;__main__&#34;:
    from eclipse.src.encryption_utils import encrypt_message, decrypt_message

    message = &#34;HELLO THIS IS A LONG MESSAGE&#34;
    encrypted = encrypt_message(message, &#34;password&#34;)
    d = DCT(&#34;eclipse/resources/test_image.jpg&#34;, encrypted)
    encoded = d.embed_msg(&#34;eclipse/resources/ycrcb_output.png&#34;, 20)
    decoded = DCT.extract_msg(&#34;eclipse/resources/ycrcb_output.png&#34;, 20)
    decoded_message = decrypt_message(decoded, &#34;password&#34;)
    print(decoded_message)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="eclipse.src.discrete_cosine_transform_tool.dct"><code class="name flex">
<span>def <span class="ident">dct</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>dct(src[, dst[, flags]]) -&gt; dst
.
@brief Performs a forward or inverse discrete Cosine transform of 1D or 2D array.
. <br>
.
The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D
.
floating-point array:
.
-
Forward Cosine transform of a 1D vector of N elements:
.
\f[Y = C^{(N)}
\cdot X\f]
.
where
.
\f[C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )\f]
.
and
.
\f$\alpha_0=1\f$, \f$\alpha_j=2\f$ for <em>j > 0</em>.
.
-
Inverse Cosine transform of a 1D vector of N elements:
.
\f[X =
\left (C^{(N)} \right )^{-1}
\cdot Y =
\left (C^{(N)} \right )^T
\cdot Y\f]
.
(since \f$C^{(N)}\f$ is an orthogonal matrix, \f$C^{(N)} \cdot \left(C^{(N)}\right)^T = I\f$ )
.
-
Forward 2D Cosine transform of M x N matrix:
.
\f[Y = C^{(N)}
\cdot X
\cdot \left (C^{(N)} \right )^T\f]
.
-
Inverse 2D Cosine transform of M x N matrix:
.
\f[X =
\left (C^{(N)} \right )^T
\cdot X
\cdot C^{(N)}\f]
. <br>
.
The function chooses the mode of operation by looking at the flags and size of the input array:
.
-
If (flags &amp; #DCT_INVERSE) == 0 , the function does a forward 1D or 2D transform. Otherwise, it
.
is an inverse 1D or 2D transform.
.
-
If (flags &amp; #DCT_ROWS) != 0 , the function performs a 1D transform of each row.
.
-
If the array is a single column or a single row, the function performs a 1D transform.
.
-
If none of the above is true, the function performs a 2D transform.
. <br>
.
@note Currently dct supports even-size arrays (2, 4, 6 &hellip;). For data analysis and approximation, you
.
can pad the array when necessary.
.
Also, the function performance depends very much, and not monotonically, on the array size (see
.
getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT
.
of a vector of size N/2 . Thus, the optimal DCT size N1 >= N can be calculated as:
.
@code
.
size_t getOptimalDCTSize(size_t N) { return 2<em>getOptimalDFTSize((N+1)/2); }
.
N1 = getOptimalDCTSize(N);
.
@endcode
.
@param src input floating-point array.
.
@param dst output array of the same size and type as src .
.
@param flags transformation flags as a combination of cv::DftFlags (DCT_</em>)
.
@sa dft , getOptimalDFTSize , idct</p></section>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.idct"><code class="name flex">
<span>def <span class="ident">idct</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>idct(src[, dst[, flags]]) -&gt; dst
.
@brief Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.
. <br>
.
idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).
.
@param src input floating-point single-channel array.
.
@param dst output array of the same size and type as src.
.
@param flags operation flags.
.
@sa
dct, dft, idft, getOptimalDFTSize</p></section>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.imwrite"><code class="name flex">
<span>def <span class="ident">imwrite</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>imwrite(filename, img[, params]) -&gt; retval
.
@brief Saves an image to a specified file.
. <br>
.
The function imwrite saves the image to the specified file. The image format is chosen based on the
.
filename extension (see cv::imread for the list of extensions). In general, only 8-bit
.
single-channel or 3-channel (with 'BGR' channel order) images
.
can be saved using this function, with these exceptions:
. <br>
.
- 16-bit unsigned (CV_16U) images can be saved in the case of PNG, JPEG 2000, and TIFF formats
.
- 32-bit float (CV_32F) images can be saved in PFM, TIFF, OpenEXR, and Radiance HDR formats;
.
3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding
.
(4 bytes per pixel)
.
- PNG images with an alpha channel can be saved using this function. To do this, create
.
8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels
.
should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).
. <br>
.
If the format, depth or channel order is different, use
.
Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O
.
functions to save the image to XML or YAML format.
. <br>
.
The sample below shows how to create a BGRA image and save it to a PNG file. It also demonstrates how to set custom
.
compression parameters:
.
@include snippets/imgcodecs_imwrite.cpp
.
@param filename Name of the file.
.
@param img Image to be saved.
.
@param params Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, &hellip; .) see cv::ImwriteFlags</p></section>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) -&gt; dst
.
@brief Resizes an image.
. <br>
.
The function resize resizes the image src down to or up to the specified size. Note that the
.
initial dst type or size are not taken into account. Instead, the size and type are derived from
.
the <code>src</code>,<code>dsize</code>,<code>fx</code>, and <code>fy</code>. If you want to resize src so that it fits the pre-created dst,
.
you may call the function as follows:
.
@code
.
// explicitly specify dsize=dst.size(); fx and fy will be computed from that.
.
resize(src, dst, dst.size(), 0, 0, interpolation);
.
@endcode
.
If you want to decimate the image by factor of 2 in each direction, you can call the function this
.
way:
.
@code
.
// specify fx and fy and let the function compute the destination image size.
.
resize(src, dst, Size(), 0.5, 0.5, interpolation);
.
@endcode
.
To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to
.
enlarge an image, it will generally look best with c#INTER_CUBIC (slow) or #INTER_LINEAR
.
(faster but still looks OK).
. <br>
.
@param src input image.
.
@param dst output image; it has the size dsize (when it is non-zero) or the size computed from
.
src.size(), fx, and fy; the type of dst is the same as of src.
.
@param dsize output image size; if it equals zero, it is computed as:
.
\f[\texttt{dsize = Size(round(fx<em>src.cols), round(fy</em>src.rows))}\f]
.
Either dsize or both fx and fy must be non-zero.
.
@param fx scale factor along the horizontal axis; when it equals 0, it is computed as
.
\f[\texttt{(double)dsize.width/src.cols}\f]
.
@param fy scale factor along the vertical axis; when it equals 0, it is computed as
.
\f[\texttt{(double)dsize.height/src.rows}\f]
.
@param interpolation interpolation method, see #InterpolationFlags
. <br>
.
@sa
warpAffine, warpPerspective, remap</p></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT"><code class="flex name class">
<span>class <span class="ident">DCT</span></span>
<span>(</span><span>cover_image_path, cipher_msg)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DCT:
    def __init__(self, cover_image_path, cipher_msg):
        self.__cover_image_path_ = abspath(cover_image_path)
        self.__cover_image_ = utils.get_image(cover_image_path)
        self.verify_and_apply_padding()
        self.__height_, self.__width_ = self.__cover_image_.shape[:2]
        self.__cipher_text_ = cipher_msg
        self.__bin_message_ = BitArray(bytes=cipher_msg).bin
        self.__message_length_ = len(self.__bin_message_)
        self.verify_ciphertext_size()

        self.__block_list_ = None

    # VERIFICATION METHODS ============================================================

    def verify_ciphertext_size(self):
        &#34;&#34;&#34;
        Verifies that the length of the message to hide
        is shorter than the maximum available space in the image.
        Warning is raised if the message length is &gt; (10% of the available capacity).
        &#34;&#34;&#34;
        area = self.__height_ * self.__width_
        if area &lt; 64:  # 64 -&gt; since each quantized block is a matrix of 8x8
            raise ValueError(
                &#34;The chosen cover image is too small (area &lt; 64 px)&#34;)
        tot_blocks = self.__height_ * self.__width_ // 64
        if self.__message_length_ &gt; tot_blocks:
            raise OverflowError(&#34;Cannot embed. Message is too long!&#34;)
        if self.__message_length_ &gt; tot_blocks / 10:
            purcentage_of_occupied_storage = round(
                self.__message_length_ / tot_blocks * 100)
            warning = f&#34;Message occupies ≈ &#34; \
                      f&#34;{purcentage_of_occupied_storage}% of the pic. &#34; \
                      &#34;A smaller text is preferred (&lt; 10%)&#34;
            warn(warning)

    def verify_and_apply_padding(self):
        &#34;&#34;&#34;
        Checks and eventually resizes image applying a padding
        if any side length is not a multiple of 8.
        The original image is eventually replaced by the padded
        (with sides multiple of 8) image.
        &#34;&#34;&#34;
        original_height, original_width = self.__cover_image_.shape[:2]
        if original_height % 8 != 0 or original_width % 8 != 0:
            self.__cover_image_ = resize(self.__cover_image_, (
                original_width + (8 - original_width % 8),
                original_height + (8 - original_height % 8)))
            imwrite(self.__cover_image_path_, self.__cover_image_)

    # BREAK/RECOMPOSE METHODS =========================================================

    @staticmethod
    def break_image_into_blocks(img: np.ndarray) -&gt; list:
        &#34;&#34;&#34;
        Breaks the coverimage into a sequence of 8x8 blocks,
        from top left to bottom right.
        :param img: Coverimage to break into n 8x8 blocks.
        :return: List of blocks of pixels [LIST OF NUMPY NDARRAY]
        &#34;&#34;&#34;
        if not isinstance(img, np.ndarray):
            raise TypeError(&#34;Cannot break a non np.array image&#34;)
        height, width = len(img), len(img[0])
        return [img[j: j + 8, i: i + 8] for (j, i) in
                product(range(0, height, 8), range(0, width, 8))
                ]

    def recompose_image(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Inverse of method &#39;breakImageIntoBlocks&#39;:
        Recompose the image from the sorted list of blocks of pixels &#39;__block_list_&#39;.
        :return: Re-composed image [NUMPY NDARRAY]
        &#34;&#34;&#34;
        if len(self.__block_list_) == 0:
            raise ValueError
        full_image = np.zeros(shape=(self.__height_, self.__width_),
                              dtype=np.uint8)  # Builds empty image
        for i in range(len(self.__block_list_)):  # Filling image
            curr_col_index = 8 * (i % (self.__width_ // 8))
            curr_line_index = 8 * (i // (self.__width_ // 8))
            full_image[
            curr_line_index:curr_line_index + 8,
            curr_col_index:curr_col_index + 8
            ] = self.__block_list_[i]
        return full_image

    # QUANTIZATION METHODS ============================================================

    @staticmethod
    def quantize_block(block: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Centers values of a block, runs it through DCT func. and quantizes it.
        :param block: 8x8 block of pixels [NUMPY NDARRAY]
        :return:Quantized 8x8 block of pixels [NUMPY NDARRAY]
        &#34;&#34;&#34;
        img_block = np.subtract(block, 128)
        dct_block = dct(img_block.astype(np.float64))
        dct_block[0][0] /= settings.QUANTIZATION_TABLE[0][0]
        dct_block[0][0] = np.round(dct_block[0][0])
        return dct_block

    @staticmethod
    def get_original_block_from_quantized(quantized_block: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Inverse of &#34;getQuantizedBlock&#34;.
        :param quantized_block: Quantized 8x8 block of pixels [NUMPY NDARRAY]
        :return: Original 8x8 block of pixels [NUMPY NDARRAY]
        &#34;&#34;&#34;
        dct_block = quantized_block
        dct_block[0][0] *= settings.QUANTIZATION_TABLE[0][0]
        unquantized_block = idct(dct_block)
        return np.add(unquantized_block, 128)

    # LENGTH EMBED/EXTRACT METHODS ====================================================

    def length_to_binary(self) -&gt; list:
        &#34;&#34;&#34;
        Gives binary form of the length and adds a separator to that representation.
        :return: Binary representation of the length + separator to embed [LIST OF STR]
        &#34;&#34;&#34;
        if self.__message_length_ % 8 != 0:
            raise ValueError(&#34;Message length is not multiple of 8&#34;)
        msg_length = int(
            self.__message_length_ / 8
        )  # Decimal representation of the length
        n_required_bits = msg_length.bit_length()
        tmp = f&#34;0{n_required_bits}b&#34;
        binary_length = format(msg_length, tmp)
        return list(binary_length) + utils.string_to_binary(
            settings.LENGTH_MSG_SEPARATOR)

    def embed_msg_length(self):
        &#34;&#34;&#34;
        Inserts the length of the message and end symbol (in binary form)
        at the beginning of the picture.
        At the end, &#39;__block_list_&#39; will be the image with embedded length,
        as list of blocks of pixels (from top left to bottom right) [LIST OF
                                                                    NUMPY NDARRAY]
        &#34;&#34;&#34;
        mess_len_to_binary = self.length_to_binary()
        for block_index, length_bit_to_embed in enumerate(mess_len_to_binary):
            quantized_block = self.quantize_block(
                self.__block_list_[block_index])
            if quantized_block[0][0] % 2 == 1 and int(length_bit_to_embed) == 0:
                quantized_block[0][0] -= 1
            elif quantized_block[0][0] % 2 == 0 and int(
                    length_bit_to_embed) == 1:
                quantized_block[0][0] += 1
            self.__block_list_[
                block_index] = self.get_original_block_from_quantized(
                quantized_block)

    @staticmethod
    def extract_msg_length(img: np.ndarray) -&gt; int:
        &#34;&#34;&#34;
        Extracts the length (in bits) of the message embedded in the stegoimage.
        :param img: Stegoimage from which to extract the message [NUMPY NDARRAY]
        :return: Length of the message to extract from the stegoimage [INT]
        &#34;&#34;&#34;
        block_index = 0
        separator_found = False
        decoded_length = &#34;&#34;
        while (not separator_found) and (
                block_index &lt; settings.MAX_BITS_TO_ENCODE_LENGTH):
            block = utils.extract_block_from_image(img, block_index)
            unquantized_block = DCT.quantize_block(block)
            decoded_length += str(int(unquantized_block[0][0] % 2))
            if len(decoded_length) &gt; 8:
                current_letter = str(chr(int(decoded_length[-8:], 2)))
                if current_letter == settings.LENGTH_MSG_SEPARATOR:
                    separator_found = True
            block_index += 1
        return int(&#39;&#39;.join(decoded_length[:-8]), 2) * 8

    # ENCODE/DECODE MESSAGE METHODS ===================================================

    @staticmethod
    def get_random_blocks_from_msg_length(seed: int,
                                          binary_msg_length: int,
                                          height: int,
                                          width: int) -&gt; list:
        &#34;&#34;&#34;
        Generates a random sequence of indices, (interpreted as the position
        of bits of the message to embed/extract in/from the cover/stegoimage.
        :param seed: Chosen seed [INT]
        :param binary_msg_length: length of the message to extract
                                  from the stegoimage [INT]
        :param height: Height of the cover/stegoimage [INT]
        :param width: Width of the cover/stegoimage [INT]
        :return: List of indexes [LIST OF INT]
        &#34;&#34;&#34;
        tot_blocks = height * width // 64
        random.seed(seed)
        chosen_blocks_indices = random.sample(
            range(settings.MAX_BITS_TO_ENCODE_LENGTH, tot_blocks),
            binary_msg_length)
        return chosen_blocks_indices

    def embed_msg(self, output_path: str, seed: int) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Embed message into cover image:
        1 - Embed the length.
        2 - Embed the message equally distributing bits according
            to a random sequence of indices
            and inserting them in the LSB of DCT quantized blocks.
        :param output_path: Path of stegoimage that will be generated
                            after message insertion [STR]
        :param seed: Chosen seed [INT]
        :return: Stegoimage [NUMPY NDARRAY]
        &#34;&#34;&#34;
        y, cr, cb = utils.get_YCrCb_from_original_img(self.__cover_image_)
        mess_len = len(self.__cipher_text_)
        positions_lst = self.get_random_blocks_from_msg_length(seed, mess_len * 8,
                                                               self.__height_,
                                                               self.__width_)
        self.__block_list_ = self.break_image_into_blocks(cb)
        self.embed_msg_length()
        for message_index, block_index in enumerate(positions_lst):
            block = self.__block_list_[block_index]
            dct_block = self.quantize_block(block)
            coeff = int(dct_block[0][0])

            message_bit = self.__bin_message_[message_index]
            if (coeff % 2) == 1 and int(message_bit) == 0:
                dct_block[0][0] -= 1
            elif (coeff % 2) == 0 and int(message_bit) == 1:
                dct_block[0][0] += 1

            self.__block_list_[block_index] = self.get_original_block_from_quantized(
                dct_block
            )
        modified_cb = self.recompose_image()
        final_img_standard_format = utils.get_original_img_from_YCrCb(y,
                                                                      cr,
                                                                      modified_cb)
        imwrite(output_path, final_img_standard_format)
        return final_img_standard_format

    @staticmethod
    def extract_msg(stego_img_path: str, seed: int) -&gt; bytes:
        &#34;&#34;&#34;
        Extract a message from a stegoimage:
        1 - Extract the length of the message.
        2 - Generate the random sequence of indices.
        3 - Extract the message.
        :param stego_img_path: Path of stegoimage
                               from which to extract the message [STR]
        :param seed: Chosen seed [INT]
        :return: Message hidden in the stegoimage [BYTE STR]
        &#34;&#34;&#34;
        original_stego_img = utils.get_image(stego_img_path)
        _, _, cb = utils.get_YCrCb_from_original_img(original_stego_img)
        height, width = original_stego_img.shape[:2]
        msg_length = DCT.extract_msg_length(cb)
        positions_lst = DCT.get_random_blocks_from_msg_length(
            seed, msg_length, height, width)
        decoded_msg = &#34;0b&#34;
        block_list = DCT.break_image_into_blocks(cb)
        for message_index, block_index in enumerate(positions_lst):
            block_index = positions_lst[message_index]
            block = block_list[block_index]
            dct_block = DCT.quantize_block(block)
            coeff = int(dct_block[0][0])
            decoded_msg += str(
                coeff % 2)  # Adding to the message the currently read bit
        return BitArray(decoded_msg).bytes</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.break_image_into_blocks"><code class="name flex">
<span>def <span class="ident">break_image_into_blocks</span></span>(<span>img)</span>
</code></dt>
<dd>
<section class="desc"><p>Breaks the coverimage into a sequence of 8x8 blocks,
from top left to bottom right.
:param img: Coverimage to break into n 8x8 blocks.
:return: List of blocks of pixels [LIST OF NUMPY NDARRAY]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def break_image_into_blocks(img: np.ndarray) -&gt; list:
    &#34;&#34;&#34;
    Breaks the coverimage into a sequence of 8x8 blocks,
    from top left to bottom right.
    :param img: Coverimage to break into n 8x8 blocks.
    :return: List of blocks of pixels [LIST OF NUMPY NDARRAY]
    &#34;&#34;&#34;
    if not isinstance(img, np.ndarray):
        raise TypeError(&#34;Cannot break a non np.array image&#34;)
    height, width = len(img), len(img[0])
    return [img[j: j + 8, i: i + 8] for (j, i) in
            product(range(0, height, 8), range(0, width, 8))
            ]</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.extract_msg"><code class="name flex">
<span>def <span class="ident">extract_msg</span></span>(<span>stego_img_path, seed)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract a message from a stegoimage:
1 - Extract the length of the message.
2 - Generate the random sequence of indices.
3 - Extract the message.
:param stego_img_path: Path of stegoimage
from which to extract the message [STR]
:param seed: Chosen seed [INT]
:return: Message hidden in the stegoimage [BYTE STR]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def extract_msg(stego_img_path: str, seed: int) -&gt; bytes:
    &#34;&#34;&#34;
    Extract a message from a stegoimage:
    1 - Extract the length of the message.
    2 - Generate the random sequence of indices.
    3 - Extract the message.
    :param stego_img_path: Path of stegoimage
                           from which to extract the message [STR]
    :param seed: Chosen seed [INT]
    :return: Message hidden in the stegoimage [BYTE STR]
    &#34;&#34;&#34;
    original_stego_img = utils.get_image(stego_img_path)
    _, _, cb = utils.get_YCrCb_from_original_img(original_stego_img)
    height, width = original_stego_img.shape[:2]
    msg_length = DCT.extract_msg_length(cb)
    positions_lst = DCT.get_random_blocks_from_msg_length(
        seed, msg_length, height, width)
    decoded_msg = &#34;0b&#34;
    block_list = DCT.break_image_into_blocks(cb)
    for message_index, block_index in enumerate(positions_lst):
        block_index = positions_lst[message_index]
        block = block_list[block_index]
        dct_block = DCT.quantize_block(block)
        coeff = int(dct_block[0][0])
        decoded_msg += str(
            coeff % 2)  # Adding to the message the currently read bit
    return BitArray(decoded_msg).bytes</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.extract_msg_length"><code class="name flex">
<span>def <span class="ident">extract_msg_length</span></span>(<span>img)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts the length (in bits) of the message embedded in the stegoimage.
:param img: Stegoimage from which to extract the message [NUMPY NDARRAY]
:return: Length of the message to extract from the stegoimage [INT]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def extract_msg_length(img: np.ndarray) -&gt; int:
    &#34;&#34;&#34;
    Extracts the length (in bits) of the message embedded in the stegoimage.
    :param img: Stegoimage from which to extract the message [NUMPY NDARRAY]
    :return: Length of the message to extract from the stegoimage [INT]
    &#34;&#34;&#34;
    block_index = 0
    separator_found = False
    decoded_length = &#34;&#34;
    while (not separator_found) and (
            block_index &lt; settings.MAX_BITS_TO_ENCODE_LENGTH):
        block = utils.extract_block_from_image(img, block_index)
        unquantized_block = DCT.quantize_block(block)
        decoded_length += str(int(unquantized_block[0][0] % 2))
        if len(decoded_length) &gt; 8:
            current_letter = str(chr(int(decoded_length[-8:], 2)))
            if current_letter == settings.LENGTH_MSG_SEPARATOR:
                separator_found = True
        block_index += 1
    return int(&#39;&#39;.join(decoded_length[:-8]), 2) * 8</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.get_original_block_from_quantized"><code class="name flex">
<span>def <span class="ident">get_original_block_from_quantized</span></span>(<span>quantized_block)</span>
</code></dt>
<dd>
<section class="desc"><p>Inverse of "getQuantizedBlock".
:param quantized_block: Quantized 8x8 block of pixels [NUMPY NDARRAY]
:return: Original 8x8 block of pixels [NUMPY NDARRAY]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_original_block_from_quantized(quantized_block: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Inverse of &#34;getQuantizedBlock&#34;.
    :param quantized_block: Quantized 8x8 block of pixels [NUMPY NDARRAY]
    :return: Original 8x8 block of pixels [NUMPY NDARRAY]
    &#34;&#34;&#34;
    dct_block = quantized_block
    dct_block[0][0] *= settings.QUANTIZATION_TABLE[0][0]
    unquantized_block = idct(dct_block)
    return np.add(unquantized_block, 128)</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.get_random_blocks_from_msg_length"><code class="name flex">
<span>def <span class="ident">get_random_blocks_from_msg_length</span></span>(<span>seed, binary_msg_length, height, width)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a random sequence of indices, (interpreted as the position
of bits of the message to embed/extract in/from the cover/stegoimage.
:param seed: Chosen seed [INT]
:param binary_msg_length: length of the message to extract
from the stegoimage [INT]
:param height: Height of the cover/stegoimage [INT]
:param width: Width of the cover/stegoimage [INT]
:return: List of indexes [LIST OF INT]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_random_blocks_from_msg_length(seed: int,
                                      binary_msg_length: int,
                                      height: int,
                                      width: int) -&gt; list:
    &#34;&#34;&#34;
    Generates a random sequence of indices, (interpreted as the position
    of bits of the message to embed/extract in/from the cover/stegoimage.
    :param seed: Chosen seed [INT]
    :param binary_msg_length: length of the message to extract
                              from the stegoimage [INT]
    :param height: Height of the cover/stegoimage [INT]
    :param width: Width of the cover/stegoimage [INT]
    :return: List of indexes [LIST OF INT]
    &#34;&#34;&#34;
    tot_blocks = height * width // 64
    random.seed(seed)
    chosen_blocks_indices = random.sample(
        range(settings.MAX_BITS_TO_ENCODE_LENGTH, tot_blocks),
        binary_msg_length)
    return chosen_blocks_indices</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.quantize_block"><code class="name flex">
<span>def <span class="ident">quantize_block</span></span>(<span>block)</span>
</code></dt>
<dd>
<section class="desc"><p>Centers values of a block, runs it through DCT func. and quantizes it.
:param block: 8x8 block of pixels [NUMPY NDARRAY]
:return:Quantized 8x8 block of pixels [NUMPY NDARRAY]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def quantize_block(block: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Centers values of a block, runs it through DCT func. and quantizes it.
    :param block: 8x8 block of pixels [NUMPY NDARRAY]
    :return:Quantized 8x8 block of pixels [NUMPY NDARRAY]
    &#34;&#34;&#34;
    img_block = np.subtract(block, 128)
    dct_block = dct(img_block.astype(np.float64))
    dct_block[0][0] /= settings.QUANTIZATION_TABLE[0][0]
    dct_block[0][0] = np.round(dct_block[0][0])
    return dct_block</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.embed_msg"><code class="name flex">
<span>def <span class="ident">embed_msg</span></span>(<span>self, output_path, seed)</span>
</code></dt>
<dd>
<section class="desc"><p>Embed message into cover image:
1 - Embed the length.
2 - Embed the message equally distributing bits according
to a random sequence of indices
and inserting them in the LSB of DCT quantized blocks.
:param output_path: Path of stegoimage that will be generated
after message insertion [STR]
:param seed: Chosen seed [INT]
:return: Stegoimage [NUMPY NDARRAY]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embed_msg(self, output_path: str, seed: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Embed message into cover image:
    1 - Embed the length.
    2 - Embed the message equally distributing bits according
        to a random sequence of indices
        and inserting them in the LSB of DCT quantized blocks.
    :param output_path: Path of stegoimage that will be generated
                        after message insertion [STR]
    :param seed: Chosen seed [INT]
    :return: Stegoimage [NUMPY NDARRAY]
    &#34;&#34;&#34;
    y, cr, cb = utils.get_YCrCb_from_original_img(self.__cover_image_)
    mess_len = len(self.__cipher_text_)
    positions_lst = self.get_random_blocks_from_msg_length(seed, mess_len * 8,
                                                           self.__height_,
                                                           self.__width_)
    self.__block_list_ = self.break_image_into_blocks(cb)
    self.embed_msg_length()
    for message_index, block_index in enumerate(positions_lst):
        block = self.__block_list_[block_index]
        dct_block = self.quantize_block(block)
        coeff = int(dct_block[0][0])

        message_bit = self.__bin_message_[message_index]
        if (coeff % 2) == 1 and int(message_bit) == 0:
            dct_block[0][0] -= 1
        elif (coeff % 2) == 0 and int(message_bit) == 1:
            dct_block[0][0] += 1

        self.__block_list_[block_index] = self.get_original_block_from_quantized(
            dct_block
        )
    modified_cb = self.recompose_image()
    final_img_standard_format = utils.get_original_img_from_YCrCb(y,
                                                                  cr,
                                                                  modified_cb)
    imwrite(output_path, final_img_standard_format)
    return final_img_standard_format</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.embed_msg_length"><code class="name flex">
<span>def <span class="ident">embed_msg_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Inserts the length of the message and end symbol (in binary form)
at the beginning of the picture.
At the end, '__block_list_' will be the image with embedded length,
as list of blocks of pixels (from top left to bottom right) [LIST OF
NUMPY NDARRAY]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embed_msg_length(self):
    &#34;&#34;&#34;
    Inserts the length of the message and end symbol (in binary form)
    at the beginning of the picture.
    At the end, &#39;__block_list_&#39; will be the image with embedded length,
    as list of blocks of pixels (from top left to bottom right) [LIST OF
                                                                NUMPY NDARRAY]
    &#34;&#34;&#34;
    mess_len_to_binary = self.length_to_binary()
    for block_index, length_bit_to_embed in enumerate(mess_len_to_binary):
        quantized_block = self.quantize_block(
            self.__block_list_[block_index])
        if quantized_block[0][0] % 2 == 1 and int(length_bit_to_embed) == 0:
            quantized_block[0][0] -= 1
        elif quantized_block[0][0] % 2 == 0 and int(
                length_bit_to_embed) == 1:
            quantized_block[0][0] += 1
        self.__block_list_[
            block_index] = self.get_original_block_from_quantized(
            quantized_block)</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.length_to_binary"><code class="name flex">
<span>def <span class="ident">length_to_binary</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gives binary form of the length and adds a separator to that representation.
:return: Binary representation of the length + separator to embed [LIST OF STR]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length_to_binary(self) -&gt; list:
    &#34;&#34;&#34;
    Gives binary form of the length and adds a separator to that representation.
    :return: Binary representation of the length + separator to embed [LIST OF STR]
    &#34;&#34;&#34;
    if self.__message_length_ % 8 != 0:
        raise ValueError(&#34;Message length is not multiple of 8&#34;)
    msg_length = int(
        self.__message_length_ / 8
    )  # Decimal representation of the length
    n_required_bits = msg_length.bit_length()
    tmp = f&#34;0{n_required_bits}b&#34;
    binary_length = format(msg_length, tmp)
    return list(binary_length) + utils.string_to_binary(
        settings.LENGTH_MSG_SEPARATOR)</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.recompose_image"><code class="name flex">
<span>def <span class="ident">recompose_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Inverse of method 'breakImageIntoBlocks':
Recompose the image from the sorted list of blocks of pixels '__block_list_'.
:return: Re-composed image [NUMPY NDARRAY]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recompose_image(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Inverse of method &#39;breakImageIntoBlocks&#39;:
    Recompose the image from the sorted list of blocks of pixels &#39;__block_list_&#39;.
    :return: Re-composed image [NUMPY NDARRAY]
    &#34;&#34;&#34;
    if len(self.__block_list_) == 0:
        raise ValueError
    full_image = np.zeros(shape=(self.__height_, self.__width_),
                          dtype=np.uint8)  # Builds empty image
    for i in range(len(self.__block_list_)):  # Filling image
        curr_col_index = 8 * (i % (self.__width_ // 8))
        curr_line_index = 8 * (i // (self.__width_ // 8))
        full_image[
        curr_line_index:curr_line_index + 8,
        curr_col_index:curr_col_index + 8
        ] = self.__block_list_[i]
    return full_image</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.verify_and_apply_padding"><code class="name flex">
<span>def <span class="ident">verify_and_apply_padding</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks and eventually resizes image applying a padding
if any side length is not a multiple of 8.
The original image is eventually replaced by the padded
(with sides multiple of 8) image.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_and_apply_padding(self):
    &#34;&#34;&#34;
    Checks and eventually resizes image applying a padding
    if any side length is not a multiple of 8.
    The original image is eventually replaced by the padded
    (with sides multiple of 8) image.
    &#34;&#34;&#34;
    original_height, original_width = self.__cover_image_.shape[:2]
    if original_height % 8 != 0 or original_width % 8 != 0:
        self.__cover_image_ = resize(self.__cover_image_, (
            original_width + (8 - original_width % 8),
            original_height + (8 - original_height % 8)))
        imwrite(self.__cover_image_path_, self.__cover_image_)</code></pre>
</details>
</dd>
<dt id="eclipse.src.discrete_cosine_transform_tool.DCT.verify_ciphertext_size"><code class="name flex">
<span>def <span class="ident">verify_ciphertext_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Verifies that the length of the message to hide
is shorter than the maximum available space in the image.
Warning is raised if the message length is &gt; (10% of the available capacity).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_ciphertext_size(self):
    &#34;&#34;&#34;
    Verifies that the length of the message to hide
    is shorter than the maximum available space in the image.
    Warning is raised if the message length is &gt; (10% of the available capacity).
    &#34;&#34;&#34;
    area = self.__height_ * self.__width_
    if area &lt; 64:  # 64 -&gt; since each quantized block is a matrix of 8x8
        raise ValueError(
            &#34;The chosen cover image is too small (area &lt; 64 px)&#34;)
    tot_blocks = self.__height_ * self.__width_ // 64
    if self.__message_length_ &gt; tot_blocks:
        raise OverflowError(&#34;Cannot embed. Message is too long!&#34;)
    if self.__message_length_ &gt; tot_blocks / 10:
        purcentage_of_occupied_storage = round(
            self.__message_length_ / tot_blocks * 100)
        warning = f&#34;Message occupies ≈ &#34; \
                  f&#34;{purcentage_of_occupied_storage}% of the pic. &#34; \
                  &#34;A smaller text is preferred (&lt; 10%)&#34;
        warn(warning)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eclipse.src" href="index.html">eclipse.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.dct" href="#eclipse.src.discrete_cosine_transform_tool.dct">dct</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.idct" href="#eclipse.src.discrete_cosine_transform_tool.idct">idct</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.imwrite" href="#eclipse.src.discrete_cosine_transform_tool.imwrite">imwrite</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.resize" href="#eclipse.src.discrete_cosine_transform_tool.resize">resize</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT" href="#eclipse.src.discrete_cosine_transform_tool.DCT">DCT</a></code></h4>
<ul class="">
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.break_image_into_blocks" href="#eclipse.src.discrete_cosine_transform_tool.DCT.break_image_into_blocks">break_image_into_blocks</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.embed_msg" href="#eclipse.src.discrete_cosine_transform_tool.DCT.embed_msg">embed_msg</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.embed_msg_length" href="#eclipse.src.discrete_cosine_transform_tool.DCT.embed_msg_length">embed_msg_length</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.extract_msg" href="#eclipse.src.discrete_cosine_transform_tool.DCT.extract_msg">extract_msg</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.extract_msg_length" href="#eclipse.src.discrete_cosine_transform_tool.DCT.extract_msg_length">extract_msg_length</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.get_original_block_from_quantized" href="#eclipse.src.discrete_cosine_transform_tool.DCT.get_original_block_from_quantized">get_original_block_from_quantized</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.get_random_blocks_from_msg_length" href="#eclipse.src.discrete_cosine_transform_tool.DCT.get_random_blocks_from_msg_length">get_random_blocks_from_msg_length</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.length_to_binary" href="#eclipse.src.discrete_cosine_transform_tool.DCT.length_to_binary">length_to_binary</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.quantize_block" href="#eclipse.src.discrete_cosine_transform_tool.DCT.quantize_block">quantize_block</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.recompose_image" href="#eclipse.src.discrete_cosine_transform_tool.DCT.recompose_image">recompose_image</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.verify_and_apply_padding" href="#eclipse.src.discrete_cosine_transform_tool.DCT.verify_and_apply_padding">verify_and_apply_padding</a></code></li>
<li><code><a title="eclipse.src.discrete_cosine_transform_tool.DCT.verify_ciphertext_size" href="#eclipse.src.discrete_cosine_transform_tool.DCT.verify_ciphertext_size">verify_ciphertext_size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>